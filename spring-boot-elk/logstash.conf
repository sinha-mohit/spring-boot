input {
  beats {
    port => 5000
    client_inactivity_timeout => 300
    id => "beats_input"
  }
}

filter {
  if [json_error] {
    drop { }
  }

  date {
    match => [ "timestamp", "ISO8601" ]
    target => "@timestamp"
    remove_field => ["timestamp"]
  }

  if [exception] != "" and [exception] != null {
    grok {
      match => { "exception" => "^%{JAVACLASS:exception_class}(: %{JAVALOGMESSAGE:exception_message})?\n" }
      overwrite => ["exception_class", "exception_message"]
    }
  }

  mutate {
    remove_field => ["@version", "prospector", "beat", "input", "offset", "type"]
  }

  if "_grokparsefailure" in [tags] {
    mutate {
      add_field => { "grok_error" => "true" }
    }
  }
}

output {
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    index => "spring-boot-logs-%{+YYYY.MM.dd}"
    template_overwrite => true
    retry_on_conflict => 3
    action => "index"
    timeout => 120
    pool_max => 1000
    pool_max_per_route => 100
  }
    stdout {
      codec => rubydebug
    }
}
